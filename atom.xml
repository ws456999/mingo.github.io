<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-04T11:29:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片预览的几种方法</title>
    <link href="http://yoursite.com/2017/03/04/img-preview/"/>
    <id>http://yoursite.com/2017/03/04/img-preview/</id>
    <published>2017-03-04T11:17:54.000Z</published>
    <updated>2017-03-04T11:29:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>方法有三种：</p>
<ol>
<li>选择文件后直上传然后得到网络url</li>
<li>用HTML5的File API的FileReader图片本地转成base64格式的url</li>
<li>用URL.createObjectURL(file)对象方法创建临时路径</li>
</ol>
<a id="more"></a>
<h2 id="选择文件后直接上传然后得到网络url"><a href="#选择文件后直接上传然后得到网络url" class="headerlink" title="选择文件后直接上传然后得到网络url"></a>选择文件后直接上传然后得到网络url</h2><p>利用2、3方法先将图片传到服务器，再使用服务器里面的绝对地址</p>
<h2 id="用HTML5的File-API的FileReader获取图片的base64字符串"><a href="#用HTML5的File-API的FileReader获取图片的base64字符串" class="headerlink" title="用HTML5的File API的FileReader获取图片的base64字符串"></a>用HTML5的File API的FileReader获取图片的base64字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面是使用vue的写法</span></div><div class="line"></div><div class="line">imgPreview (file) &#123;</div><div class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">// 看支持不支持FileReader</span></div><div class="line">    <span class="keyword">if</span> (!file || !<span class="built_in">window</span>.FileReader) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/^image/</span>.test(file.type)) &#123;</div><div class="line">        <span class="comment">// 创建一个reader</span></div><div class="line">        <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">        <span class="comment">// 将图片将转成 base64 格式</span></div><div class="line">        reader.readAsDataURL(file);</div><div class="line">        <span class="comment">// 读取成功后的回调</span></div><div class="line">        reader.onloadend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 将图片展示</span></div><div class="line">            self.dataUrl = reader.result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;,</div><div class="line">handleFileChange (e) &#123;</div><div class="line">    ...</div><div class="line">    this.file = inputDOM.files[<span class="number">0</span>];</div><div class="line">    ...</div><div class="line">    <span class="comment">// 在获取到文件对象进行预览就行了！</span></div><div class="line">    <span class="keyword">this</span>.imgPreview(<span class="keyword">this</span>.file);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="URL-对象方法创建临时路径"><a href="#URL-对象方法创建临时路径" class="headerlink" title="URL 对象方法创建临时路径"></a>URL 对象方法创建临时路径</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">imgBlob = imgInput.files[<span class="number">0</span>] <span class="comment">// 获取blob对象</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> srcTemp = URL.createObjectURL(imgBlob) <span class="comment">// 创建临时路径</span></div><div class="line"></div><div class="line">URL.revokeObjectURL(srcTemp) <span class="comment">// 销毁临时路径</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方法有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择文件后直上传然后得到网络url&lt;/li&gt;
&lt;li&gt;用HTML5的File API的FileReader图片本地转成base64格式的url&lt;/li&gt;
&lt;li&gt;用URL.createObjectURL(file)对象方法创建临时路径&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>什么是webpack</title>
    <link href="http://yoursite.com/2017/03/04/webpack-little/"/>
    <id>http://yoursite.com/2017/03/04/webpack-little/</id>
    <published>2017-03-04T11:10:00.000Z</published>
    <updated>2017-03-04T11:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是之前为了组内技术分享的时候准备的，虽然那个时候讲的不太好，现在贴出来告诉自己以后要做的更好</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><hr>
<p>当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用各种更新的技术来开发，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码。</p>
<a id="more"></a>
<p>前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。</p>
<p>它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法</p>
<ul>
<li>模块化，让我们可以把复杂的程序细化为小的文件;</li>
<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；</li>
<li>Scss，less等CSS预处理器</li>
</ul>
<h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><hr>
<p>模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库。</p>
<p>这种原始的加载方式暴露了一些显而易见的弊端：</p>
<ul>
<li>全局作用域下容易造成变量冲突</li>
<li>文件只能按照 &lt; script &gt; 的书写顺序进行加载</li>
<li>开发人员必须主观解决模块和代码库的依赖关系</li>
<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>
</ul>
<p>这时候就出现了一些模块化的解决方案</p>
<h3 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>（”vue”）</div><div class="line"><span class="built_in">require</span>(“../file.js”)</div><div class="line"><span class="built_in">module</span>.exports = something</div></pre></td></tr></table></figure>
<p>优点：<br>服务器端模块便于重用<br>NPM 中已经有将近20万个可以使用模块包<br>简单并容易使用</p>
<p>缺点：<br>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的<br>不能非阻塞的并行加载多个模块</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">define(“jq”, “lodash”, funciton (d1, d2) &#123;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Requirejs<br>优点：</p>
<p>适合在浏览器环境中异步加载模块<br>可以并行加载多个模块<br>缺点：</p>
<p>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅<br>不符合通用的模块化思维方式，是一种妥协的实现</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, export, module</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</div><div class="line">  	<span class="keyword">var</span> Spinning = <span class="built_in">require</span>(<span class="string">'./spinning'</span>);</div><div class="line">	exports.doSomething = ...</div><div class="line">  	module.exports = ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>优点：<br>依赖就近，延迟执行<br>可以很容易在 Node.js 中运行<br>缺点：</p>
<p>依赖 SPM 打包，模块的加载逻辑偏重</p>
<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">        <span class="comment">// AMD. Register as an anonymous module.</span></div><div class="line">        define([<span class="string">'exports'</span>, <span class="string">'b'</span>], factory);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> exports.nodeName !== <span class="string">'string'</span>) &#123;</div><div class="line">        <span class="comment">// CommonJS</span></div><div class="line">        factory(exports, <span class="built_in">require</span>(<span class="string">'b'</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Browser globals</span></div><div class="line">        factory((root.commonJsStrict = &#123;&#125;), root.b);</div><div class="line">    &#125;</div><div class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">exports, b</span>) </span>&#123;</div><div class="line">    <span class="comment">//use b in some fashion.</span></div><div class="line"></div><div class="line">    <span class="comment">// attach properties to the exports object to define</span></div><div class="line">    <span class="comment">// the exported module properties.</span></div><div class="line">    exports.action = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<h3 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"jquery"</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>优点：<br>容易进行静态分析<br>面向未来的 EcmaScript 标准</p>
<p>缺点：<br>原生浏览器端还没有实现该标准<br>全新的命令字，新版的 Node.js才支持</p>
<p>具体实现的话：babel</p>
<h3 id="我们期待的模块系统"><a href="#我们期待的模块系统" class="headerlink" title="我们期待的模块系统"></a>我们期待的模块系统</h3><p>可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅只是 JavaScript 模块化，还有 CSS、图片、字体等资源也需要模块化。</p>
<p>前端模块加载</p>
<h3 id="前端模块加载"><a href="#前端模块加载" class="headerlink" title="前端模块加载"></a>前端模块加载</h3><p>前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。</p>
<p>模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。</p>
<p>分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。</p>
<p>要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇是之前为了组内技术分享的时候准备的，虽然那个时候讲的不太好，现在贴出来告诉自己以后要做的更好&lt;/p&gt;
&lt;h2 id=&quot;现状&quot;&gt;&lt;a href=&quot;#现状&quot; class=&quot;headerlink&quot; title=&quot;现状&quot;&gt;&lt;/a&gt;现状&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;当今越来越多的网站已经从网页模式进化到了 Webapp 模式。它们运行在现代的高级浏览器里，使用各种更新的技术来开发，网页已经不仅仅是完成浏览的基本需求，并且webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git commit 规范</title>
    <link href="http://yoursite.com/2017/03/04/commit-msg/"/>
    <id>http://yoursite.com/2017/03/04/commit-msg/</id>
    <published>2017-03-04T11:01:04.000Z</published>
    <updated>2017-03-04T11:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>git commit 一些规范</p>
<a id="more"></a>
<blockquote>
<p><a href="http://karma-runner.github.io/0.10/dev/git-commit-msg.html" target="_blank" rel="external">原文链接</a></p>
</blockquote>
<h2 id="提交commit的一些格式"><a href="#提交commit的一些格式" class="headerlink" title="提交commit的一些格式:"></a>提交commit的一些格式:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;footer&gt;</div></pre></td></tr></table></figure>
<h2 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h2><hr>
<h4 id="通常第一行不会超过70个字符，第二行一般都是空白行，后面的每行都不应该超过80个字符"><a href="#通常第一行不会超过70个字符，第二行一般都是空白行，后面的每行都不应该超过80个字符" class="headerlink" title="通常第一行不会超过70个字符，第二行一般都是空白行，后面的每行都不应该超过80个字符"></a>通常第一行不会超过70个字符，第二行一般都是空白行，后面的每行都不应该超过80个字符</h4><blockquote>
<p><em>Allowed <type> values:</type></em></p>
</blockquote>
<ul>
<li><strong>feat</strong> (新feature)</li>
<li><strong>fix</strong> (修复bug)</li>
<li><strong>docs</strong> (修改文档)</li>
<li><strong>style</strong> (css修改)</li>
<li><strong>refactor</strong> (代码重构)</li>
<li><strong>test</strong> (测试相关)</li>
<li><strong>chore</strong> (更新自动化任务，不修改业务代码)</li>
</ul>
<blockquote>
<p><em>Example <scope> values:</scope></em></p>
</blockquote>
<ul>
<li>init</li>
<li>runner</li>
<li>watcher</li>
<li>config</li>
<li>web-server</li>
<li>proxy</li>
<li>etc.</li>
</ul>
<p>The <scope> can be empty (eg. if the change is a global or difficult to assign to a single component), in which case the parentheses are omitted.</scope></p>
<h2 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h2><hr>
<ul>
<li>uses the imperative, present tense: “change” not “changed” nor “changes”</li>
<li>includes motivation for the change and contrasts with previous behavior</li>
</ul>
<p>For more info about message body, see:</p>
<ul>
<li><a href="http://365git.tumblr.com/post/3308646748/writing-git-commit-messages" target="_blank" rel="external">http://365git.tumblr.com/post/3308646748/writing-git-commit-messages</a></li>
<li><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="external">http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git commit 一些规范&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>https笔记</title>
    <link href="http://yoursite.com/2017/03/04/https/"/>
    <id>http://yoursite.com/2017/03/04/https/</id>
    <published>2017-03-04T10:52:19.000Z</published>
    <updated>2017-03-04T11:09:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>Https是就是套在SSL/TLS内的http，也就是安全的http。何为安全？一个安全的网络通信环境要解决3个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 通信内容的保密</div><div class="line">2. 通信双方身份的真实</div><div class="line">3. 通信内容的完整</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Https-是利用非对对称加密算法"><a href="#Https-是利用非对对称加密算法" class="headerlink" title="Https 是利用非对对称加密算法"></a><strong>Https 是利用非对对称加密算法</strong></h2><blockquote>
<p>对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。你可能比较好奇非对称加密算法的原理，但是我这里不展开讲算法，有兴趣的同学可以自行搜索。  </p>
</blockquote>
<p>如果小红用她的私钥加密的话，班上所有人都知道公钥，而公钥可以解私钥的加密，也意味着所有人都能解密小红的回应消息。聪明的你一定想到了解决方案：利用非对称加密算法加密出一个对称密钥给小红，小红用她的私钥读取对称密钥，然后你们就用这个对称密钥来做对称加密，然后就可以愉快地约约约了。</p>
<p>当然，https也是这么干的。</p>
<p>上面的例子的意思是：<br>私钥可以解读公钥要加的数据，私钥加密的数据可以由公钥来解读</p>
<p>小红自己有一个私钥，其余每个人都有一串公钥，所以我们利用对称密钥加密出一个密钥给小红，让小红用这个给进行消息的加密并反馈。</p>
<h2 id="通信双方身份的真实"><a href="#通信双方身份的真实" class="headerlink" title="通信双方身份的真实"></a><strong>通信双方身份的真实</strong></h2><p>为了防止掉包事件的发生</p>
<p>所有加密通信都要带上一本证，用来证明自己的身份。这本证是凤姐特意为班上所有单身狗做的，公钥就放在证书里面返回给纸条的发送者，证书里面除了公钥还有学号、人名、甚至星座身高三围等各种信息。证书上盖了一个大大的鉴定章，这是凤姐独有的章，表示证上的信息真实性由凤姐保证，看到这个章就可以认为对方是个真·单身狗。</p>
<p>通过这些信息你就可以知道对方是小红还是如花了，这就是证书机制。</p>
<p>证书上的公章也是非对称加密过的，加密方式跟上面提到的刚好相反：用凤姐的私钥加密，用凤姐公钥就可以解密，这样就可以鉴定证书的真伪。这个公章就是证书的数字签名，具体来说就是先将证书用哈希算法提取摘要，然后对摘要进行加密的过程。另外你也可以直接拿着证书去找凤姐，凤姐就会帮你验证证书的有效性。（证书是有期限的，所以即使是真证书也会可能过期，需要注意）</p>
<p>这个机制看起来相当完善，但是我们要以怀疑一切的态度去做安全机制，凤姐保证的东西是可信任的了。</p>
<h2 id="通信内容的完整"><a href="#通信内容的完整" class="headerlink" title="通信内容的完整"></a><strong>通信内容的完整</strong></h2><p>为了防止通信内容的完整性与一致性</p>
<p>这种篡改通信内容的场景相信大家都深有体会，我们访问一些站点的时候无缘无故就出现了运营商的广告，这都是运营商给加的！！所以内容的完整性也需要保证，这比较简单：先用哈希算法提取内容摘要，然后对摘要进行加密生成数字签名，验证数字签名就可以判断出通信内容的完整性了。</p>
<p>以上就是https用到技术的简化版，一个http通信流程如下：</p>
<p><img src="https://github.com/ws456999/ws456999.github.io/blob/master/https.png?raw=true" alt="https流程"></p>
<p>大体步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 客户端发送Client Hello报文开始SSL通信，报文中包含SSL版本、可用算法列表、密钥长度等。</div><div class="line">2. 服务器支持SSL通信时，会以Server Hello报文作为应答，报文中同样包括SSL版本以及加密算法配置，也就是协商加解密算法。</div><div class="line">3. 然后服务器会发送Certificate报文，也就是将证书发送给客户端。</div><div class="line">4. 客户端发送Client Key Exchange报文，使用3中的证书公钥加密Pre-master secret随机密码串，后续就以这个密码来做对称加密进行通信。</div><div class="line">5. 服务器使用私钥解密成功后返回一个响应提示SSL通信环境已经搭建好了。</div><div class="line">6. 然后就是常规的http c/s通信。</div></pre></td></tr></table></figure></p>
<p>根据前文所述，在步骤3和步骤6都会使用摘要和签名算法来保证传递的证书和通信内容不被篡改。通过这个流程可以看出，https的核心在于加密，尤其是非对称加密算法被多次使用来传送关键信息。</p>
<p>理解了加密，认识到网络的透明性，抱着怀疑一切的态度，理解https这套体系就变得简单了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;https&quot;&gt;&lt;a href=&quot;#https&quot; class=&quot;headerlink&quot; title=&quot;https&quot;&gt;&lt;/a&gt;https&lt;/h1&gt;&lt;p&gt;Https是就是套在SSL/TLS内的http，也就是安全的http。何为安全？一个安全的网络通信环境要解决3个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1. 通信内容的保密&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2. 通信双方身份的真实&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3. 通信内容的完整&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/03/04/hello-world/"/>
    <id>http://yoursite.com/2017/03/04/hello-world/</id>
    <published>2017-03-04T10:48:05.000Z</published>
    <updated>2017-03-04T10:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>wr的第二个博客，一个博客源码丢了现在重新开始写一个</p>
<p>这个是hello world篇</p>
<p>2017-03-04 12:20:27</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wr的第二个博客，一个博客源码丢了现在重新开始写一个&lt;/p&gt;
&lt;p&gt;这个是hello world篇&lt;/p&gt;
&lt;p&gt;2017-03-04 12:20:27&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式（一）</title>
    <link href="http://yoursite.com/2017/03/04/regex-01/"/>
    <id>http://yoursite.com/2017/03/04/regex-01/</id>
    <published>2017-03-04T10:48:05.000Z</published>
    <updated>2017-03-04T10:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>常年没有写过正则了，今天来好好学习一波，有点长，留着点东西准备些下一篇</p>
<p>先放一波格式化代码<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正则添加千分位</span></div><div class="line"><span class="comment">//参数说明：num 要格式化的数字 n 保留小数位</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNum</span>(<span class="params">num,n</span>)</span>&#123;</div><div class="line">  num = <span class="built_in">String</span>(num.toFixed(n))</div><div class="line">  <span class="keyword">var</span> re = <span class="regexp">/(-?\d+)(\d&#123;3&#125;)/</span></div><div class="line">  <span class="keyword">while</span>(re.test(num)) &#123;</div><div class="line">    num = num.replace(re,<span class="string">"$1,$2"</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> num</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="贪婪模式跟非贪婪模式"><a href="#贪婪模式跟非贪婪模式" class="headerlink" title="贪婪模式跟非贪婪模式"></a>贪婪模式跟非贪婪模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"aaab"</span>,</div><div class="line">reg1 = <span class="regexp">/a+/</span>, <span class="comment">//贪婪模式</span></div><div class="line">reg2 = <span class="regexp">/a+?/</span>;<span class="comment">//非贪婪模式</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg1)); <span class="comment">//["aaa"], 由于是贪婪模式, 捕获了所有的a</span></div><div class="line"><span class="built_in">console</span>.log(str.match(regs)); <span class="comment">//["a"], 由于是非贪婪模式, 只捕获到第一个a</span></div><div class="line">(\+<span class="number">86</span>)?<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span>;</div><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/&lt;div.*&lt;\/div&gt;/</span>; <span class="comment">//方案一,贪婪匹配</span></div><div class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/&lt;div.*?&lt;\/div&gt;/</span>;<span class="comment">//方案二,非贪婪匹配</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg1));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg2));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;"</span></div></pre></td></tr></table></figure>
<h2 id="区间量词的非贪婪模式"><a href="#区间量词的非贪婪模式" class="headerlink" title="区间量词的非贪婪模式"></a>区间量词的非贪婪模式</h2><p>一般情况下, 非贪婪模式, 我们使用的是<code>*?</code>, 或 <code>+?</code> 这种形式, 还有一种是 <code>{n,m}?</code>.<br>区间量词<code>{n,m}</code> 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而<code>{n,m}?</code> 则表示在区间范围内, 尽可能少的匹配.</p>
<p>需要注意的是:</p>
<ul>
<li>能达到同样匹配结果的贪婪与非贪婪模式, 通常是贪婪模式的匹配效率较高.</li>
<li>所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.</li>
<li>贪婪模式可以与固化分组(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后可以紧跟限定词表示重复次数. 如下, 小括号内包裹的abc便是一个分组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(abc)+<span class="regexp">/.test("abc123") == true</span></div></pre></td></tr></table></figure>
<p>那么分组有什么用呢? 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获, 请往下看.</p>
<h2 id="捕获性分组"><a href="#捕获性分组" class="headerlink" title="捕获性分组"></a>捕获性分组</h2><p>捕获性分组, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, js中主要是通过 <code>$+</code> 编号 或者 +编号 表示法进行引用. 如下便是一个捕获性分组的例子.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</div><div class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);<span class="comment">//自然也可以写成 "$1~~"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//808080</span></div><div class="line"><span class="built_in">console</span>.log(output);<span class="comment">//808080~~</span></div></pre></td></tr></table></figure>
<p>以上, <code>(\d+)</code> 表示一个捕获性分组, <code>RegExp.\$1</code> 指向该分组捕获的内容. <code>$+编号</code> 这种引用通常在正则表达式之外使用. <code>+编号</code> 这种引用却可以在正则表达式中使用, 可用于匹配不同位置相同部分的子串.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"www.google.google.com"</span>;</div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/([a-z]+)\.\1/</span>; <span class="comment">// ps：前面（）中使用的是贪婪模式</span></div><div class="line"><span class="built_in">console</span>.log(url.replace(re,<span class="string">"$1"</span>));<span class="comment">//"www.google.com"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>) <span class="comment">// "google"</span></div></pre></td></tr></table></figure>
<h2 id="非捕获性分组"><a href="#非捕获性分组" class="headerlink" title="非捕获性分组"></a>非捕获性分组</h2><p>非捕获性分组, 通常由一对括号加上<code>?:</code>加上子表达式组成, 非捕获性分组不会创建反向引用, 就好像没有括号一样. 如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</div><div class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(?:\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(output);<span class="comment">//$1~~</span></div></pre></td></tr></table></figure>
<p>以上, <code>(?:\d+)</code> 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, <code>$1</code> 指向空字符串.<br>实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.</p>
<h2 id="命名分组"><a href="#命名分组" class="headerlink" title="命名分组"></a>命名分组</h2><p>语法: (?…)</p>
<p>命名分组也是捕获性分组, 它将匹配的字符串捕获到一个组名称或编号名称中, 在获得匹配结果后, 可通过分组名进行获取.（ javaScript 中不支持命名分组 ）</p>
<h2 id="固化分组"><a href="#固化分组" class="headerlink" title="固化分组"></a>固化分组</h2><p>固化分组, 又叫原子组.</p>
<p>语法: (?&gt;…)</p>
<p>如上所述, 我们在使用非贪婪模式时, 匹配过程中可能会进行多次的回溯, 回溯越多, 正则表达式的运行效率就越低. 而固化分组就是用来减少回溯次数的.（ javaScript 中不支持固话分组 ）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常年没有写过正则了，今天来好好学习一波，有点长，留着点东西准备些下一篇&lt;/p&gt;
&lt;p&gt;先放一波格式化代码&lt;br&gt;
    
    </summary>
    
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
</feed>
