<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-04T11:05:15.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git commit msg</title>
    <link href="http://yoursite.com/2017/03/04/commit-msg/"/>
    <id>http://yoursite.com/2017/03/04/commit-msg/</id>
    <published>2017-03-04T11:01:04.000Z</published>
    <updated>2017-03-04T11:05:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>git commit 一些规范</p>
<a id="more"></a>
<blockquote>
<p><a href="http://karma-runner.github.io/0.10/dev/git-commit-msg.html" target="_blank" rel="external">原文链接</a></p>
</blockquote>
<h2 id="Format-of-the-commit-message"><a href="#Format-of-the-commit-message" class="headerlink" title="Format of the commit message:"></a>Format of the commit message:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;footer&gt;</div></pre></td></tr></table></figure>
<h2 id="Message-subject-first-line"><a href="#Message-subject-first-line" class="headerlink" title="Message subject (first line)"></a>Message subject (first line)</h2><hr>
<h4 id="First-line-cannot-be-longer-than-70-characters-second-line-is-always-blank-and-other-lines-should-be-wrapped-at-80-characters"><a href="#First-line-cannot-be-longer-than-70-characters-second-line-is-always-blank-and-other-lines-should-be-wrapped-at-80-characters" class="headerlink" title="First line cannot be longer than 70 characters, second line is always blank and other lines should be wrapped at 80 characters."></a>First line cannot be longer than 70 characters, second line is always blank and other lines should be wrapped at 80 characters.</h4><blockquote>
<p><em>Allowed <type> values:</type></em>  </p>
</blockquote>
<ul>
<li><strong>feat</strong> (new feature)</li>
<li><strong>fix</strong> (bug fix)</li>
<li><strong>docs</strong> (changes to documentation)</li>
<li><strong>style</strong> (formatting, missing semi colons, etc; no code change)</li>
<li><strong>refactor</strong> (refactoring production code)</li>
<li><strong>test</strong> (adding missing tests, refactoring tests; no production code change)</li>
<li><strong>chore</strong> (updating grunt tasks etc; no production code change)</li>
</ul>
<blockquote>
<p><em>Example <scope> values:</scope></em>  </p>
</blockquote>
<ul>
<li>init</li>
<li>runner</li>
<li>watcher</li>
<li>config</li>
<li>web-server</li>
<li>proxy</li>
<li>etc.</li>
</ul>
<p>The <scope> can be empty (eg. if the change is a global or difficult to assign to a single component), in which case the parentheses are omitted.</scope></p>
<h2 id="Message-body"><a href="#Message-body" class="headerlink" title="Message body"></a>Message body</h2><hr>
<ul>
<li>uses the imperative, present tense: “change” not “changed” nor “changes”</li>
<li>includes motivation for the change and contrasts with previous behavior</li>
</ul>
<p>For more info about message body, see:</p>
<ul>
<li><a href="http://365git.tumblr.com/post/3308646748/writing-git-commit-messages" target="_blank" rel="external">http://365git.tumblr.com/post/3308646748/writing-git-commit-messages</a></li>
<li><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="external">http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git commit 一些规范&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>https笔记</title>
    <link href="http://yoursite.com/2017/03/04/https/"/>
    <id>http://yoursite.com/2017/03/04/https/</id>
    <published>2017-03-04T10:52:19.000Z</published>
    <updated>2017-03-04T11:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>Https是就是套在SSL/TLS内的http，也就是安全的http。何为安全？一个安全的网络通信环境要解决3个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 通信内容的保密</div><div class="line">2. 通信双方身份的真实</div><div class="line">3. 通信内容的完整</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Https-是利用非对对称加密算法"><a href="#Https-是利用非对对称加密算法" class="headerlink" title="Https 是利用非对对称加密算法"></a><strong>Https 是利用非对对称加密算法</strong></h2><blockquote>
<p>对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。你可能比较好奇非对称加密算法的原理，但是我这里不展开讲算法，有兴趣的同学可以自行搜索。  </p>
</blockquote>
<p>如果小红用她的私钥加密的话，班上所有人都知道公钥，而公钥可以解私钥的加密，也意味着所有人都能解密小红的回应消息。聪明的你一定想到了解决方案：利用非对称加密算法加密出一个对称密钥给小红，小红用她的私钥读取对称密钥，然后你们就用这个对称密钥来做对称加密，然后就可以愉快地约约约了。</p>
<p>当然，https也是这么干的。</p>
<p>上面的例子的意思是：<br>私钥可以解读公钥要加的数据，私钥加密的数据可以由公钥来解读</p>
<p>小红自己有一个私钥，其余每个人都有一串公钥，所以我们利用对称密钥加密出一个密钥给小红，让小红用这个给进行消息的加密并反馈。</p>
<h2 id="通信双方身份的真实"><a href="#通信双方身份的真实" class="headerlink" title="通信双方身份的真实"></a><strong>通信双方身份的真实</strong></h2><p>为了防止掉包事件的发生</p>
<p>所有加密通信都要带上一本证，用来证明自己的身份。这本证是凤姐特意为班上所有单身狗做的，公钥就放在证书里面返回给纸条的发送者，证书里面除了公钥还有学号、人名、甚至星座身高三围等各种信息。证书上盖了一个大大的鉴定章，这是凤姐独有的章，表示证上的信息真实性由凤姐保证，看到这个章就可以认为对方是个真·单身狗。</p>
<p>通过这些信息你就可以知道对方是小红还是如花了，这就是证书机制。</p>
<p>证书上的公章也是非对称加密过的，加密方式跟上面提到的刚好相反：用凤姐的私钥加密，用凤姐公钥就可以解密，这样就可以鉴定证书的真伪。这个公章就是证书的数字签名，具体来说就是先将证书用哈希算法提取摘要，然后对摘要进行加密的过程。另外你也可以直接拿着证书去找凤姐，凤姐就会帮你验证证书的有效性。（证书是有期限的，所以即使是真证书也会可能过期，需要注意）</p>
<p>这个机制看起来相当完善，但是我们要以怀疑一切的态度去做安全机制，凤姐保证的东西是可信任的了。</p>
<h2 id="通信内容的完整"><a href="#通信内容的完整" class="headerlink" title="通信内容的完整"></a><strong>通信内容的完整</strong></h2><p>为了防止通信内容的完整性与一致性</p>
<p>这种篡改通信内容的场景相信大家都深有体会，我们访问一些站点的时候无缘无故就出现了运营商的广告，这都是运营商给加的！！所以内容的完整性也需要保证，这比较简单：先用哈希算法提取内容摘要，然后对摘要进行加密生成数字签名，验证数字签名就可以判断出通信内容的完整性了。</p>
<p>以上就是https用到技术的简化版，一个http通信流程如下：</p>
<p><img src="img/https.png" alt="https流程"></p>
<p>大体步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. 客户端发送Client Hello报文开始SSL通信，报文中包含SSL版本、可用算法列表、密钥长度等。</div><div class="line">2. 服务器支持SSL通信时，会以Server Hello报文作为应答，报文中同样包括SSL版本以及加密算法配置，也就是协商加解密算法。</div><div class="line">3. 然后服务器会发送Certificate报文，也就是将证书发送给客户端。</div><div class="line">4. 客户端发送Client Key Exchange报文，使用3中的证书公钥加密Pre-master secret随机密码串，后续就以这个密码来做对称加密进行通信。</div><div class="line">5. 服务器使用私钥解密成功后返回一个响应提示SSL通信环境已经搭建好了。</div><div class="line">6. 然后就是常规的http c/s通信。</div></pre></td></tr></table></figure></p>
<p>根据前文所述，在步骤3和步骤6都会使用摘要和签名算法来保证传递的证书和通信内容不被篡改。通过这个流程可以看出，https的核心在于加密，尤其是非对称加密算法被多次使用来传送关键信息。</p>
<p>理解了加密，认识到网络的透明性，抱着怀疑一切的态度，理解https这套体系就变得简单了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;https&quot;&gt;&lt;a href=&quot;#https&quot; class=&quot;headerlink&quot; title=&quot;https&quot;&gt;&lt;/a&gt;https&lt;/h1&gt;&lt;p&gt;Https是就是套在SSL/TLS内的http，也就是安全的http。何为安全？一个安全的网络通信环境要解决3个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1. 通信内容的保密&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2. 通信双方身份的真实&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3. 通信内容的完整&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/03/04/hello-world/"/>
    <id>http://yoursite.com/2017/03/04/hello-world/</id>
    <published>2017-03-04T10:48:05.000Z</published>
    <updated>2017-03-04T10:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>wr的第二个博客，一个博客源码丢了现在重新开始写一个</p>
<p>这个是hello world篇</p>
<p>2017-03-04 12:20:27</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wr的第二个博客，一个博客源码丢了现在重新开始写一个&lt;/p&gt;
&lt;p&gt;这个是hello world篇&lt;/p&gt;
&lt;p&gt;2017-03-04 12:20:27&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式（一）</title>
    <link href="http://yoursite.com/2017/03/04/regex-01/"/>
    <id>http://yoursite.com/2017/03/04/regex-01/</id>
    <published>2017-03-04T10:48:05.000Z</published>
    <updated>2017-03-04T10:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>常年没有写过正则了，今天来好好学习一波，有点长，留着点东西准备些下一篇</p>
<p>先放一波格式化代码<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正则添加千分位</span></div><div class="line"><span class="comment">//参数说明：num 要格式化的数字 n 保留小数位</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNum</span>(<span class="params">num,n</span>)</span>&#123;</div><div class="line">  num = <span class="built_in">String</span>(num.toFixed(n))</div><div class="line">  <span class="keyword">var</span> re = <span class="regexp">/(-?\d+)(\d&#123;3&#125;)/</span></div><div class="line">  <span class="keyword">while</span>(re.test(num)) &#123;</div><div class="line">    num = num.replace(re,<span class="string">"$1,$2"</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> num</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="贪婪模式跟非贪婪模式"><a href="#贪婪模式跟非贪婪模式" class="headerlink" title="贪婪模式跟非贪婪模式"></a>贪婪模式跟非贪婪模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"aaab"</span>,</div><div class="line">reg1 = <span class="regexp">/a+/</span>, <span class="comment">//贪婪模式</span></div><div class="line">reg2 = <span class="regexp">/a+?/</span>;<span class="comment">//非贪婪模式</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg1)); <span class="comment">//["aaa"], 由于是贪婪模式, 捕获了所有的a</span></div><div class="line"><span class="built_in">console</span>.log(str.match(regs)); <span class="comment">//["a"], 由于是非贪婪模式, 只捕获到第一个a</span></div><div class="line">(\+<span class="number">86</span>)?<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;</div></pre></td></tr></table></figure>
<p>实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span>;</div><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/&lt;div.*&lt;\/div&gt;/</span>; <span class="comment">//方案一,贪婪匹配</span></div><div class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/&lt;div.*?&lt;\/div&gt;/</span>;<span class="comment">//方案二,非贪婪匹配</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg1));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;&lt;input type='text'/&gt;&lt;/div&gt;"</span></div><div class="line"><span class="built_in">console</span>.log(str.match(reg2));<span class="comment">//"&lt;div class='v1'&gt;&lt;div class='v2'&gt;test&lt;/div&gt;"</span></div></pre></td></tr></table></figure>
<h2 id="区间量词的非贪婪模式"><a href="#区间量词的非贪婪模式" class="headerlink" title="区间量词的非贪婪模式"></a>区间量词的非贪婪模式</h2><p>一般情况下, 非贪婪模式, 我们使用的是<code>*?</code>, 或 <code>+?</code> 这种形式, 还有一种是 <code>{n,m}?</code>.<br>区间量词<code>{n,m}</code> 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而<code>{n,m}?</code> 则表示在区间范围内, 尽可能少的匹配.</p>
<p>需要注意的是:</p>
<ul>
<li>能达到同样匹配结果的贪婪与非贪婪模式, 通常是贪婪模式的匹配效率较高.</li>
<li>所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.</li>
<li>贪婪模式可以与固化分组(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后可以紧跟限定词表示重复次数. 如下, 小括号内包裹的abc便是一个分组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(abc)+<span class="regexp">/.test("abc123") == true</span></div></pre></td></tr></table></figure>
<p>那么分组有什么用呢? 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获, 请往下看.</p>
<h2 id="捕获性分组"><a href="#捕获性分组" class="headerlink" title="捕获性分组"></a>捕获性分组</h2><p>捕获性分组, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, js中主要是通过 <code>$+</code> 编号 或者 +编号 表示法进行引用. 如下便是一个捕获性分组的例子.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</div><div class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);<span class="comment">//自然也可以写成 "$1~~"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//808080</span></div><div class="line"><span class="built_in">console</span>.log(output);<span class="comment">//808080~~</span></div></pre></td></tr></table></figure>
<p>以上, <code>(\d+)</code> 表示一个捕获性分组, <code>RegExp.\$1</code> 指向该分组捕获的内容. <code>$+编号</code> 这种引用通常在正则表达式之外使用. <code>+编号</code> 这种引用却可以在正则表达式中使用, 可用于匹配不同位置相同部分的子串.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"www.google.google.com"</span>;</div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/([a-z]+)\.\1/</span>; <span class="comment">// ps：前面（）中使用的是贪婪模式</span></div><div class="line"><span class="built_in">console</span>.log(url.replace(re,<span class="string">"$1"</span>));<span class="comment">//"www.google.com"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>) <span class="comment">// "google"</span></div></pre></td></tr></table></figure>
<h2 id="非捕获性分组"><a href="#非捕获性分组" class="headerlink" title="非捕获性分组"></a>非捕获性分组</h2><p>非捕获性分组, 通常由一对括号加上<code>?:</code>加上子表达式组成, 非捕获性分组不会创建反向引用, 就好像没有括号一样. 如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"#808080"</span>;</div><div class="line"><span class="keyword">var</span> output = color.replace(<span class="regexp">/#(?:\d+)/</span>,<span class="string">"$1"</span>+<span class="string">"~~"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);<span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(output);<span class="comment">//$1~~</span></div></pre></td></tr></table></figure>
<p>以上, <code>(?:\d+)</code> 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, <code>$1</code> 指向空字符串.<br>实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.</p>
<h2 id="命名分组"><a href="#命名分组" class="headerlink" title="命名分组"></a>命名分组</h2><p>语法: (?…)</p>
<p>命名分组也是捕获性分组, 它将匹配的字符串捕获到一个组名称或编号名称中, 在获得匹配结果后, 可通过分组名进行获取.（ javaScript 中不支持命名分组 ）</p>
<h2 id="固化分组"><a href="#固化分组" class="headerlink" title="固化分组"></a>固化分组</h2><p>固化分组, 又叫原子组.</p>
<p>语法: (?&gt;…)</p>
<p>如上所述, 我们在使用非贪婪模式时, 匹配过程中可能会进行多次的回溯, 回溯越多, 正则表达式的运行效率就越低. 而固化分组就是用来减少回溯次数的.（ javaScript 中不支持固话分组 ）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常年没有写过正则了，今天来好好学习一波，有点长，留着点东西准备些下一篇&lt;/p&gt;
&lt;p&gt;先放一波格式化代码&lt;br&gt;
    
    </summary>
    
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
</feed>
